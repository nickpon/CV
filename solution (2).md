## `[optimistic-list-contains]` Поиск без блокировок в оптимистичном сортированном списке

Вспомним реализацию операции `Contains` в оптимистичном списке:

```
bool Contains(x) {
    curr = head
    while (curr->key < x) {
        curr = curr->next
    }
    return curr->key == x && !curr->marked
}
```

Пусть поиск остановился в узле, ключ в котором равен искомому ключу `x`. В таком случае результат вызова определяется флагом `marked`. 

Можно ли в таком случае выбрать чтение флага `marked` в качестве точки линеаризации вызова `Contains`?

## Решение:

Да, в данном случае можно выбрать чтение флага `marked` в качестве точки линеаризации вызова `Contains`. Из теоретической справки нам известно, что точки линеаризации для каждого метода должны быть выбраны так, чтобы порядок их исполнения автоматически задавал последовательную историю: исполнив в том же порядке сами вызовы, мы должны получить те же самые результаты (конечно же, согласованные с последовательной спецификацией). Заметим, что именно выбором чтения флага `marked` в качестве точки линеаризации вызова `Contains` можно определить порядок исполнения конкурирующих `Insert()` и `Remove()`. То есть если `Contains()` вернул `false` => на линии истории найдётся момент времени, когда искомый элемент был удалён с основной ветки. Чтобы доказать данное высказывание, стоит вспомнить, как устроен `optimistic-list`. Предположим, что `Contains()` вернул `false`, хотя некий элемент лежал на основной ветке до начала работы `Contains()`. Если данный элемент удалили, то `Contains()` остановится точно на ребре, правый конец которого рабен данному некому элементу и вернёт `true`. Противоречие.


В качестве точки линеаризации вызова Contains действительно можно выбрать чтение 
флага marked найденного узла, так как именно им можно определить порядок исполнения 
конкурирующих вставок и удалений. Это обеспечивается гарантией того, что для любого вызова 
Contains, вернувшего false, найдется момент на линейной истории, когда этого элемента действительно не было на мастере.

Предположим, что это не так, и Contains вернул false, хотя элемент X лежал в 
мастере до начала его работы. Заметим, что Contains рассматривает ребра, где левый конец 
< X, а правый >= X, а потому, если X был во время работы Contains на мастере и его не удалили, 
до окончания её работы, то Contains остановится в точности на ребре, где правый конец = X, а потому 
должен вернуть true. Получаем противоречие, а потому наше предположение неверное.
