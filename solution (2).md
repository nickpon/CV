## `[msqueue-lin-points]` Точка линеаризации для Enqueue в очереди Майкла-Скотта

Можно ли в качестве точки линеаризации для вызова `Enqueue` в очереди Майкла-Скотта выбрать тот успешный `Compare-And-Set`, который передвигает указатель `tail` на вставленный узел? 

Заметим, что его не обязательно выполняет тот же поток, который выполняет `Enqueue`.

Вопрос на понимание: почему точка линеаризации должна быть выбрана между началом и завершением вызова операции?

## Решение:

Ответ на вопрос на понимание: точки линеаризации должны быть выбраны между началом и завершением любого вызова операции, тогда результат “стягивания” вызовов в точки линеаризации не будет нарушать частичный порядок неконкурентных вызовов в исходной истории.

Ответ на основной вопрос: да, можно ли в качестве точки линеаризации для вызова `Enqueue` в очереди Майкла-Скотта выбрать тот успешный `Compare-And-Set`, который передвигает указатель `tail` на вставленный узел. Вспомним, как устроена очередь Майкла-Скотта. `Compare-And-Set` является своего рода определяющим в `Enqueue()`. Операция, которая выигрывает, добавляет свой узел раньше остальных. Методом пристального вчитывания в ответ на вопрос на понимае и раздумия понимаем, что это и означает сформулированную выше задачу по выбору точки линеаризации.

Для того, чтобы это доказать, нужно посмотреть на конкурирующие операции Enqueue.
CAS определяет порядок операций Enqueue, 
потому что, очевидно, та операция, у которой CAS
 выполнился раньше, выигрывает у конкурентов, а потому 
 привязывает свой узел раньше и закончивается раньше, чем они. 
 Это как раз и означает возможность стянуть Enqueue в точку успешного выполнения CAS 
 по перемещению tail на новый узел, так как тогда мы получим вполне определенный порядок 
 на линейной истории операций.
