## `[counter]` Распределенный счетчик

Рассмотрим реализацию монотонно растущего счетчика, значение которого распределено по нескольким атомарным ячейкам памяти для параллельного применения приращений.
Пусть со счетчиком работают `n` потоков, пронумерованных от `0` до `n-1`. 
Счетчик представляем массивом `V[0..n-1]`, который изначально заполнен нулями.
Счетчик поддерживает две операции:

`Add(x)` – поток с номером `t` прибавляет `x` к значению в ячейке `V[t]`

`Get()` – поток последовательно считывает и суммирует значения всех ячеек массива `V`

```
// n - number of threads
// t - current thread index

void Add(x) {
    V[t] += x
}

unsigned int Get() {
    total = 0
    for (int i = 0; i < n; ++i) {
        total += V[i]
    }
    return total
}
```

Таким образом, в каждую ячейку пишет только один поток.

1) Будет ли такая реализация линеаризуемой? Иначе говоря, сможет ли наблюдатель / программа отличить такой счетчик от атомарного?
2) Будет ли счетчик линеаризуемым, если заменить операцию `Add(x)` на операцию `Increment()`, которая увеличивает `V[t]` на `+1`?


## Решение:

1) Нет, к сожалению, данная реализация не будет линеаризуемой.
Докажем, что такой счетчик нелинеаризуем.

Рассмотрим 4 потока, каждый поток работает над конкретной ячейкой, в которую он записывает результат своего выполнения.

Пусть у нас первый поток вызывает `Get()`, второй - `Add(2)`, третий - `Add(4)`, четвёртый - `Add(8)`. Пусть будем также считать, что вызовы `Add(2)`, `Add(4)`, `Add(8)` упорядочены в конкурентной истории. Стоит отметить, что во всех ячейках ихначально нулевые значения.

Рассмотрим следующий выриант исполнения:

```
    T1        T2        T3        T4    
Get()
/* 
total = 0
total += V[1] (= 0)
total += V[2] (= 0) 
*/
             Add(2)
/*
V[2] += 2 (= 2)
*/
                       Add(4)
/*
V[3] += 4 (= 4)
*/                      
                                 Add(8)
/*
V[4] += 8 (= 8)
*/

/*
total += V[3] (= 4)
total += V[4] (= 12)
*/

total = 12
```

Но `Add(2)`, `Add(4)` и `Add(4)` упорядочены, то конкурирующий с ними `Get()` в последовательной истории мог записать в свою ячейку 0, 2 или 6, 10. Но в рассмотренном выше исполнении не получается ни дно из этих чисе => порядок между прибавлениями `Add()` был нарушен => нелинеаризуема.

2) Будет. Постараемся показать это.

Заметим, что в данном случае операции `Increment()` в разных потоках неотличимы друг от друга. Пусть есть набор возвращаемых значений от `Get()` + мы знаем, какие вызовы `Increment()` и `Get()` конкурируют между собой и друг с другом. Попробуем построить историю:

-- Расставим неконкурирующие вызовы `Increment()`, отнеся их к любому потоку.

-- Добавим конкурирующие между собой операций `Increment()` в произвольном порядке, соблюдая правило конкуренции.

-- Расставим `Get()`'ы. Расставляем их так, чтобы кол-во опреаций по инкрементированию было ровно столько же, сколько возвращает данный `Get()`.
