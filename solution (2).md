## Ring Buffer

1) Объяснить, какие неатомарные чтения и записи должны быть упорядочены через happens-before.
2) Показать, как алгоритм гарантирует возникновение стрелок happens-before между нужными парами запись-чтение.
3) Максимально ослабить гарантии упорядочивания.

## Решение:

1) Попробуем пояснить, какие неатомарные чтения и записи должны быть упорядочены через happens-before. На мой взгляд, должны быть упорядочены `Consume()` и `Publish()` в различных потоках. Все вызовы внутри этих методов должны быть упорядочены некоторыми списками. 
 
2) См. ответ на 3-ий вопрос для понимания расстановки `std::memory_order` во всех случаях. Но почему же гарантируется возникновение стрелок? Заметим, что записи под `std::memory_order_relaxed` проходят нормально, так как реализуются лишь одни продьюсер и консьюмер. Тогда `std::memory_order_acquire` и `std::memory_order_release` задают порядок синхронизации (synchronization order) между различными потоками. Именно поэтому и создаются стрелки happens-before.
 
3) Рассмотрим `Publish()`. Для начала ответим на вопрос, почему первое чтение `const size_t curr_head = head_.load();` нельзя сделать `std::memory_order_relaxed`. Это происходит из-за того, что, к сожалению, нет гарантии, что при чтении прочитается последняя запись. Именно поэтому там мы прописываем `std::memory_order_acquire`. Во втором чтении ` const size_t curr_tail = tail_.load();` мы тоже не можем сделать `std::memory_order_relaxed`, так как иначе не возникнут стрелки happens-before, что может привести к не очень корректному исполнению программы при работе с несколькми потоками. Аналогичные рассуждения можно провести и для `Consume()`. Отметим, что на оставшихся запясях мы можем максимально ослабить упорядочивание с помощью `std::memory_order_relaxed`, так как реализуется лишь одни продьюсер и консьюмер.
