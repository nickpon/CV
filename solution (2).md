## Double-Checked Locking

1) Объяснить, какие неатомарные чтения и записи должны быть упорядочены через happens-before.
2) Показать, как алгоритм гарантирует возникновение стрелок happens-before между нужными парами запись-чтение.
3) Максимально ослабить гарантии упорядочивания.

## Решение:

1) Попробуем пояснить, какие неатомарные чтения и записи должны быть упорядочены через happens-before. На мой взгляд, должны быть упорядочены `Get()` в различных потоках. Это происходит из-за того, что блок исполнения внутри `Get()` не является полностью атомарным.

2) См. ответ на 3-ий вопрос для понимания расстановки `std::memory_order` в трёх случаях. Но почему же гарантируется возникновение стрелок? Заметим, что второе считывание у нас происходит под мьютексом, поэтому не будут фиксироваться data races. 
Тогда `std::memory_order_acquire` и `std::memory_order_release` задают порядок синхронизации (synchronization order) между `Get()` в различных потоках. Именно поэтому и создаются стрелки happens-before.

3) Для начала ответим на вопрос, почему первое чтение `T* curr_ptr = ptr_to_value_.load()` нельзя сделать `std::memory_order_relaxed`. Это происходит из-за того, что, к сожалению, нет гарантии, что при чтении прочитается последняя запись. Именно поэтому там мы прописываем `std::memory_order_acquire`. Но уже второе чтение происходит под мьютексом, то у нас появляется порядок синхронизации (synchronization order), именно поэтому второе чтение можно сделать `std::memory_order_relaxed`. Соответственно, последняя запись должна быть с `std::memory_order_release`, тем самым возникнут стрелки happens before. Таким образом мы максимально ослабили гарантии.
