## `[optimistic-list-contains]` Поиск без блокировок в оптимистичном сортированном списке

Вспомним реализацию операции `Contains` в оптимистичном списке:

```
bool Contains(x) {
    curr = head
    while (curr->key < x) {
        curr = curr->next
    }
    return curr->key == x && !curr->marked
}
```

Пусть поиск остановился в узле, ключ в котором равен искомому ключу `x`. В таком случае результат вызова определяется флагом `marked`. 

Можно ли в таком случае выбрать чтение флага `marked` в качестве точки линеаризации вызова `Contains`?

## Решение:

Да, в данном случае можно выбрать чтение флага `marked` в качестве точки линеаризации вызова `Contains`. Из теоретической справки нам известно, что точки линеаризации для каждого метода должны быть выбраны так, чтобы порядок их исполнения автоматически задавал последовательную историю: исполнив в том же порядке сами вызовы, мы должны получить те же самые результаты (конечно же, согласованные с последовательной спецификацией). Заметим, что именно выбором чтения флага `marked` в качестве точки линеаризации вызова `Contains` можно определить порядок исполнения конкурирующих `Insert()` и `Remove()`. То есть если `Contains()` вернул `false` => на линии истории найдётся момент времени, когда искомый элемент не находился на основной ветке. Чтобы доказать данное высказывание, стоит вспомнить, как устроен `optimistic-list`. Предположим, что `Contains()` вернул `false`, хотя некий элемент лежал на основной ветке до начала работы `Contains()`. Если данный элемент удалили, то `Contains()` остановится точно на ребре, правый конец которого рабен данному некому элементу и вернёт `true`. Противоречие.
