## `[counter]` Распределенный счетчик

Рассмотрим реализацию монотонно растущего счетчика, значение которого распределено по нескольким атомарным ячейкам памяти для параллельного применения приращений.
Пусть со счетчиком работают `n` потоков, пронумерованных от `0` до `n-1`. 
Счетчик представляем массивом `V[0..n-1]`, который изначально заполнен нулями.
Счетчик поддерживает две операции:

`Add(x)` – поток с номером `t` прибавляет `x` к значению в ячейке `V[t]`

`Get()` – поток последовательно считывает и суммирует значения всех ячеек массива `V`

```
// n - number of threads
// t - current thread index

void Add(x) {
    V[t] += x
}

unsigned int Get() {
    total = 0
    for (int i = 0; i < n; ++i) {
        total += V[i]
    }
    return total
}
```

Таким образом, в каждую ячейку пишет только один поток.

1) Будет ли такая реализация линеаризуемой? Иначе говоря, сможет ли наблюдатель / программа отличить такой счетчик от атомарного?
2) Будет ли счетчик линеаризуемым, если заменить операцию Add(x) на операцию Increment(), которая увеличивает V[t]V[t]V[t] на +1+1+1?


## Решение:

1) Попробуем пояснить, какие неатомарные чтения и записи должны быть упорядочены через happens-before. На мой взгляд, должны быть упорядочены `Consume()` и `Publish()` в различных потоках. Все вызовы внутри этих методов должны быть упорядочены некоторыми списками. 
 
2) См. ответ на 3-ий вопрос для понимания расстановки `std::memory_order` во всех случаях. Но почему же гарантируется возникновение стрелок? Заметим, что записи под `std::memory_order_relaxed` проходят нормально, так как реализуются лишь один продьюсер и консьюмер. Тогда `std::memory_order_acquire` и `std::memory_order_release` задают порядок синхронизации (synchronization order) между различными потоками. Именно поэтому и создаются стрелки happens-before.
 
3) Рассмотрим `Publish()`. Для начала ответим на вопрос, почему первое чтение `const size_t curr_head = head_.load();` нельзя сделать `std::memory_order_relaxed`. Это происходит из-за того, что, к сожалению, нет гарантии, что при чтении прочитается последняя запись. Именно поэтому там мы прописываем `std::memory_order_acquire`. Во втором чтении ` const size_t curr_tail = tail_.load();` мы тоже не можем сделать `std::memory_order_relaxed`, так как иначе не возникнут стрелки happens-before, что может привести к не очень корректному исполнению программы при работе с несколькими потоками. Аналогичные рассуждения можно провести и для `Consume()`. Отметим, что на оставшихся запясях мы можем максимально ослабить упорядочивание с помощью `std::memory_order_relaxed`, так как реализуется лишь один продьюсер и консьюмер.
