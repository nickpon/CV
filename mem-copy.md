## [mem-swap] Memory-to-Memory Swap

Рассмотрим операцию `Mem-Swap(x, y)`, которая атомарно меняет местами содержимое двух ячеек памяти `x` и `y` и ничего при этом не возвращает.

Операция `Mem-Swap` на первый взгляд похожа на `r.Exchange(v)`, но они отличаются: `Exchange` меняет только одну ячейку в разделяемой памяти, в то время как `Mem-Swap` затрагивает две ячейки.

Найдите число консенсуса для этой операции.

## Решение:

Число консенсуса равно бесконечности.

Пусть у нас есть `n` потоков. Тогда заведём массив из `n` регистров `a[1 .. n]`, изначально во всех регистрах стоит 0. Также заведём отдельный регистр `r`, изначально в нём хранится 1. Первый процесс, который сделает `Mem-Swap`, выиграет.

```
decide(input: value) returns(value)
  prefer[P] := input
  swap(a[P], r)
  for Q in 1 .. n do
    if a[Q] = 1
      then return prefer[Q]
      end if
    end for
  end decide
```

Требования:
- Agreement – Рассмотрим следующее утверждения: 
1) `r = 1 или существует единственное P: a[P] = 1`,
2) `r = 0`.

Первое утверждение инвариантно, а второе постоянно и становится `r = 1` после первого `Mem-Swap`. Отсюда следует, что метод `decide` возвращает всем потокам одно и то же значение.

- Validity – Каждый поток инициализирует свою позицию в `prefer` до выполение `Mem-Swap` => валидно.

- Wait-Free Termina tion – В методе `decide` есть цикл, но он ограничен, поэтому у насть есть гарантия wait-free.
