## [mem-copy] Memory-to-Memory Copy

Рассмотрим операцию `Mem-Copy(x, y)`, которая атомарно копирует значение из ячейки `x` в ячейку `y` и ничего не возвращает (т.е. скопированное значение можно узнать только с помощью последующего чтения).

Найдите число консенсуса для этой операции.

## Решение:

Число консенсуса для `Mem-Copy(x, y)` = бесконечности.

Изначально заведём `3n` регистров:
1) `num[1..n]` - для хранениея значений, приходящими с потоками.
2) `first[1..n]` - в самом начале все элементы любые положительные числа.
3) `second[1..n]` - в самом начале все элементы любые отрицательные числа.

Рассмотрим `i`-ый поток.  Он производит запись своего числа в соответствующий ему регистр. После этого он выполняет `Mem-Copy(first[i], second[i])`. Далее данный поток присваивает любые отрицательные числа всем регистрам с `i + 1`-ого номера. 
После этого происходит следующее:
``
for (i: second[n] .. second[1]):
  if (second[i] > 0):
    print(i was the first with num[i])
    break;
``
Требования:

- Agreement: Заметим что этот ненулевой элемент, на который мы наткнулись при обратном проходе, не может быть изменён (см. алгоритм). Именно поэтому метод `Decide` будет возвращать всем потокам одно и то же значение, так как, раз они уж нашли первый ненулевой элемент, то был выполнен некоторый вызов `Mem-Copy(x, y)`.

- Validity: Каждому потоку присваивается свой отдельный регистр, с которым он работает только он и никто другой => извлечение из неё значения является валидным выбором.

- Wait-Free Termination: Линейное число операций операций, алгоритм завершается.
